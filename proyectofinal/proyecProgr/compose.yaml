services:

  goapp:
    container_name: goapp
    image: goapp:1.0.0
    build:
      context: ./backend
      dockerfile: go.dockerfile   # tu Dockerfile para Go
    environment:
      DATABASE_URL: "postgres://user_proyecto:pass_proyecto@db_proyecto:5432/db_proyecto?sslmode=disable"
    ports:
      - "8000:8000"
    depends_on:
      - db_practica   # <-- depende de tu servicio de BD
  nextapp:
    container_name: nextappdos
    image: nextappdos:1.0.0
    build:
      # Asume que el código de Next.js está en la carpeta ./frontend
      context: ./frontend
      # Asume que tu Dockerfile se llama 'Dockerfile' dentro de esa carpeta
      dockerfile: next.dockerfile
    ports:
      - '3000:3000'
    environment:
      # ¡CRUCIAL! Esta variable le dice a Next.js cómo encontrar la API del backend.
      # 'goapp' es el nombre del servicio del backend definido en este mismo archivo.
      # Docker se encarga de resolver 'goapp' a la IP interna del contenedor.
      NEXT_PUBLIC_API_URL: 'http://goapp:8000'
    depends_on:
      # Asegura que el backend 'goapp' se inicie antes que el frontend.
      - goapp
    restart: unless-stopped

  db_practica:
    container_name: db_proyecto
    image: postgres:13
    environment:
      POSTGRES_USER: user_proyecto
      POSTGRES_PASSWORD: pass_proyecto
      POSTGRES_DB: db_proyecto
    ports:
      - "5432:5432"
    volumes:
      - pgdata_proyect:/var/lib/postgresql/data
volumes:
  pgdata_proyect: {}
  
